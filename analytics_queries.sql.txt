--1. BASIC KPIs

-- Total Revenue
SELECT SUM(quantity * unit_price) AS total_revenue
FROM sales;

-- Total Units Sold
SELECT SUM(quantity) AS total_units_sold
FROM sales;

-- Number of Transactions
SELECT COUNT(*) AS total_transactions
FROM sales;

-- Average Order Value (AOV)
SELECT 
    SUM(quantity * unit_price) * 1.0 / COUNT(*) AS avg_order_value
FROM sales; -- here we use *1.0 to make the value of sum() into decimal to get the accirate vale of division( in sql 5/2 gives 2 but 5.0/2 or 5/2.0 gives 2.5)


--2. Monthly Sales & Revenue Trends using CTE

-- Monthly Revenue Trend
WITH monthly_revenue AS (
    SELECT
        DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1) AS month_start,
        SUM(quantity * unit_price) AS total_revenue
    FROM sales
    GROUP BY DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1)
)
SELECT *
FROM monthly_revenue
ORDER BY month_start;


-- Monthly Units Sold Trend
WITH monthly_units AS (
    SELECT
        DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1) AS month_start,
        SUM(quantity) AS total_units
    FROM sales
    GROUP BY DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1)
)
SELECT *
FROM monthly_units
ORDER BY month_start;


-- Monthly Average Order Value (AOV)
WITH monthly_aov AS (
    SELECT
        DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1) AS month_start,
        SUM(quantity * unit_price) * 1.0 / COUNT(*) AS avg_order_value
    FROM sales
    GROUP BY DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1)
)
SELECT *
FROM monthly_aov
ORDER BY month_start;

--3. Category analysys

SELECT 
    p.category,
    SUM(s.quantity * s.unit_price) AS total_revenue
FROM sales s
JOIN products p ON s.product_id = p.product_id
GROUP BY p.category
ORDER BY total_revenue DESC;


-- Total Units Sold by Category
SELECT 
    p.category,
    SUM(s.quantity) AS units_sold
FROM sales s
JOIN products p ON s.product_id = p.product_id
GROUP BY p.category
ORDER BY units_sold DESC;


-- Average Order Value (AOV) by Category
SELECT 
    p.category,
    SUM(s.quantity * s.unit_price) * 1.0 / COUNT(*) AS avg_order_value
FROM sales s
JOIN products p ON s.product_id = p.product_id
GROUP BY p.category
ORDER BY avg_order_value DESC;

/*----------------------combined code for above 3 category analysis

SELECT 
    p.category,
    SUM(s.quantity * s.unit_price) AS total_revenue,
    SUM(s.quantity) AS total_units_sold,
    SUM(s.quantity * s.unit_price) * 1.0 / COUNT(*) AS avg_order_value
FROM sales s
JOIN products p ON s.product_id = p.product_id
GROUP BY p.category
ORDER BY total_revenue DESC;

---------------------------------*/



-- Monthly Revenue by Category (CTE)
WITH category_monthly AS (
    SELECT 
        DATEFROMPARTS(YEAR(s.sale_date), MONTH(s.sale_date), 1) AS month_start,
        p.category,
        SUM(s.quantity * s.unit_price) AS monthly_revenue
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    GROUP BY DATEFROMPARTS(YEAR(s.sale_date), MONTH(s.sale_date), 1), p.category
)
SELECT *
FROM category_monthly
ORDER BY category, month_start;


--4. WINDOW FUNCTIONS (Ranking, Running Totals, Moving Avg)

-- 4.1 TOP-SELLING PRODUCTS BY REVENUE (RANK)

WITH product_revenue AS (
    SELECT 
        s.product_id,
        p.product_name,
        SUM(s.quantity * s.unit_price) AS total_revenue
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    GROUP BY s.product_id, p.product_name
)
SELECT 
    *,
    RANK() OVER (ORDER BY total_revenue DESC) AS revenue_rank
FROM product_revenue
ORDER BY revenue_rank;


-- 4.2 TOP-SELLING PRODUCTS BY QUANTITY (DENSE_RANK)
WITH product_qty AS (
    SELECT 
        s.product_id,
        p.product_name,
        SUM(quantity) AS total_units
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    GROUP BY s.product_id, p.product_name
)
SELECT 
    *,
    DENSE_RANK() OVER (ORDER BY total_units DESC) AS quantity_rank
FROM product_qty
ORDER BY quantity_rank;


-- 4.3 DAILY REVENUE WITH RUNNING TOTAL
WITH daily_rev AS (
    SELECT 
        sale_date,
        SUM(quantity * unit_price) AS daily_revenue
    FROM sales
    GROUP BY sale_date
)
SELECT 
    *,
    SUM(daily_revenue) OVER (ORDER BY sale_date) AS running_total_revenue
FROM daily_rev
ORDER BY sale_date;


-- 4.4 MONTHLY MOVING AVERAGE (3-MONTH WINDOW)

WITH monthly_rev AS (
    SELECT
        DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1) AS month_start,
        SUM(quantity * unit_price) AS revenue
    FROM sales s
    GROUP BY DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1)
)
SELECT 
    month_start,
    revenue,
    AVG(revenue) OVER (
        ORDER BY month_start
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS rolling_3_month_avg
FROM monthly_rev
ORDER BY month_start;


-- 4.5 MOVING AVERAGE (7-DAY ROLLING)

WITH daily_sales AS (
    SELECT 
        sale_date,
        SUM(quantity * unit_price) AS daily_revenue
    FROM sales
    GROUP BY sale_date
)
SELECT
    sale_date,
    daily_revenue,
    AVG(daily_revenue) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS rolling_7_day_avg
FROM daily_sales
ORDER BY sale_date;

-- 5. SEASONALITY ANALYSIS — BEVERAGES

-- 5.1 Monthly Beverage Sales Volume
SELECT 
    DATENAME(MONTH, sale_date) AS month_name,
    MONTH(sale_date) AS month_number,
    COUNT(*) AS beverage_transactions
FROM sales
WHERE product_id IN (108, 109, 110) -- Beverage products
GROUP BY DATENAME(MONTH, sale_date), MONTH(sale_date)
ORDER BY month_number;


-- 5.2 Beverage Revenue by Month

SELECT 
    DATENAME(MONTH, sale_date) AS month_name,
    MONTH(sale_date) AS month_number,
    SUM(quantity * unit_price) AS beverage_revenue
FROM sales
WHERE product_id IN (108, 109, 110)
GROUP BY DATENAME(MONTH, sale_date), MONTH(sale_date)
ORDER BY month_number;


-- 5.3 Beverage Revenue Trend (CTE + Ordering)

WITH beverage_monthly AS (
    SELECT
        DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1) AS month_start,
        SUM(quantity * unit_price) AS revenue
    FROM sales
    WHERE product_id IN (108, 109, 110)
    GROUP BY DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1)
)
SELECT *
FROM beverage_monthly
ORDER BY month_start;



-- 5.4 Comparing Beverages to Other Categories (Seasonality)

WITH category_monthly AS (
    SELECT 
        DATEFROMPARTS(YEAR(s.sale_date), MONTH(s.sale_date), 1) AS month_start,
        p.category,
        SUM(s.quantity * s.unit_price) AS monthly_revenue
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    GROUP BY DATEFROMPARTS(YEAR(s.sale_date), MONTH(s.sale_date), 1), p.category
)
SELECT *
FROM category_monthly
ORDER BY month_start, category;


-- 5.5 Beverage Share of Total Monthly Revenue
WITH monthly_totals AS (
    SELECT
        DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1) AS month_start,
        SUM(quantity * unit_price) AS total_revenue
    FROM sales
    GROUP BY DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1)
),
beverage_totals AS (
    SELECT
        DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1) AS month_start,
        SUM(quantity * unit_price) AS beverage_revenue
    FROM sales
    WHERE product_id IN (108, 109, 110)
    GROUP BY DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1)
)
SELECT 
    m.month_start,
    m.total_revenue,
    b.beverage_revenue,
    (b.beverage_revenue * 100.0 / m.total_revenue) AS beverage_percentage
FROM monthly_totals m
JOIN beverage_totals b ON m.month_start = b.month_start
ORDER BY m.month_start;




-- 4.6 MOVING AVERAGE (30-DAY ROLLING)

WITH daily_sales AS (
    SELECT 
        sale_date,
        SUM(quantity * unit_price) AS daily_revenue
    FROM sales
    GROUP BY sale_date
)
SELECT
    sale_date,
    daily_revenue,
    AVG(daily_revenue) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_30_day_avg
FROM daily_sales
ORDER BY sale_date;



-- 6. PRODUCT PERFORMANCE ANALYSIS

-- 6.1 Total Revenue by Product

SELECT 
    s.product_id,
    p.product_name,
    SUM(s.quantity * s.unit_price) AS total_revenue
FROM sales s
JOIN products p ON s.product_id = p.product_id
GROUP BY s.product_id, p.product_name
ORDER BY total_revenue DESC;



-- 6.2 Total Units Sold by Product

SELECT 
    s.product_id,
    p.product_name,
    SUM(s.quantity) AS total_units_sold
FROM sales s
JOIN products p ON s.product_id = p.product_id
GROUP BY s.product_id, p.product_name
ORDER BY total_units_sold DESC;



-- 6.3 Monthly Revenue Trend by Product (CTE)

WITH product_monthly AS (
    SELECT
        s.product_id,
        p.product_name,
        DATEFROMPARTS(YEAR(s.sale_date), MONTH(s.sale_date), 1) AS month_start,
        SUM(s.quantity * s.unit_price) AS monthly_revenue
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    GROUP BY s.product_id, p.product_name, DATEFROMPARTS(YEAR(s.sale_date), MONTH(s.sale_date), 1)
)
SELECT *
FROM product_monthly
ORDER BY product_id, month_start;



-- 6.4 Best & Worst Product Based on Revenue (Using RANK)

WITH product_revenue AS (
    SELECT 
        s.product_id,
        p.product_name,
        SUM(s.quantity * s.unit_price) AS revenue
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    GROUP BY s.product_id, p.product_name
)
SELECT 
    product_id,
    product_name,
    revenue,
    RANK() OVER (ORDER BY revenue DESC) AS revenue_rank
FROM product_revenue
ORDER BY revenue_rank;


-- 6.5 Product Share of Total Revenue
WITH total_rev AS (
    SELECT SUM(quantity * unit_price) AS total_revenue
    FROM sales
),
product_rev AS (
    SELECT 
        s.product_id,
        p.product_name,
        SUM(s.quantity * s.unit_price) AS product_revenue
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    GROUP BY s.product_id, p.product_name
)
SELECT 
    pr.product_id,
    pr.product_name,
    pr.product_revenue,
    (pr.product_revenue * 100.0 / tr.total_revenue) AS revenue_percentage
FROM product_rev pr
CROSS JOIN total_rev tr
ORDER BY revenue_percentage DESC;


-- 7. VENDOR PERFORMANCE ANALYSIS

-- 7.1 Total Revenue by Vendor

SELECT 
    v.vendor_name,
    SUM(s.quantity * s.unit_price) AS total_revenue
FROM sales s
JOIN products p ON s.product_id = p.product_id
JOIN vendors v ON p.vendor_id = v.vendor_id
GROUP BY v.vendor_name
ORDER BY total_revenue DESC;



-- 7.2 Total Units Sold by Vendor (Demand Level)

SELECT 
    v.vendor_name,
    SUM(s.quantity) AS total_units_sold
FROM sales s
JOIN products p ON s.product_id = p.product_id
JOIN vendors v ON p.vendor_id = v.vendor_id
GROUP BY v.vendor_name
ORDER BY total_units_sold DESC;



-- 7.3 Vendor’s Share of Total Revenue (Percentage)

WITH vendor_revenue AS (
    SELECT 
        v.vendor_name,
        SUM(s.quantity * s.unit_price) AS vendor_rev
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    JOIN vendors v ON p.vendor_id = v.vendor_id
    GROUP BY v.vendor_name
),
total_revenue AS (
    SELECT SUM(quantity * unit_price) AS total_rev
    FROM sales
)
SELECT 
    vr.vendor_name,
    vr.vendor_rev,
    (vr.vendor_rev * 100.0 / tr.total_rev) AS revenue_share_percentage
FROM vendor_revenue vr
CROSS JOIN total_revenue tr
ORDER BY revenue_share_percentage DESC;



-- 7.4 Vendor Product Performance (Which vendors supply top sellers?)

SELECT 
    v.vendor_name,
    p.product_name,
    SUM(s.quantity * s.unit_price) AS product_revenue
FROM sales s
JOIN products p ON s.product_id = p.product_id
JOIN vendors v ON p.vendor_id = v.vendor_id
GROUP BY v.vendor_name, p.product_name
ORDER BY v.vendor_name, product_revenue DESC;



-- 7.5 Vendor Monthly Revenue Trend (CTE)

WITH vendor_monthly AS (
    SELECT
        v.vendor_name,
        DATEFROMPARTS(YEAR(s.sale_date), MONTH(s.sale_date), 1) AS month_start,
        SUM(s.quantity * s.unit_price) AS monthly_revenue
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    JOIN vendors v ON p.vendor_id = v.vendor_id
    GROUP BY v.vendor_name, DATEFROMPARTS(YEAR(s.sale_date), MONTH(s.sale_date), 1)
)
SELECT *
FROM vendor_monthly
ORDER BY vendor_name, month_start;




-- 8. YEAR-OVER-YEAR (YOY) GROWTH ANALYSIS

-- 8.1 YOY Monthly Revenue Comparison (2023 vs 2024)

WITH monthly_revenue AS (
    SELECT
        YEAR(sale_date) AS sale_year,
        MONTH(sale_date) AS sale_month,
        SUM(quantity * unit_price) AS revenue
    FROM sales
    GROUP BY YEAR(sale_date), MONTH(sale_date)
)
SELECT 
    m2023.sale_month AS month,
    m2023.revenue AS revenue_2023,
    m2024.revenue AS revenue_2024,
    (m2024.revenue - m2023.revenue) AS yoy_change,
    ((m2024.revenue - m2023.revenue) * 100.0 / m2023.revenue) AS yoy_percentage
FROM monthly_revenue m2023
JOIN monthly_revenue m2024
    ON m2023.sale_month = m2024.sale_month
   AND m2023.sale_year = 2023
   AND m2024.sale_year = 2024
ORDER BY m2023.sale_month;



-- 8.2 YOY Revenue by Category

WITH category_yearly AS (
    SELECT
        p.category,
        YEAR(sale_date) AS sale_year,
        SUM(s.quantity * s.unit_price) AS revenue
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    GROUP BY p.category, YEAR(sale_date)
)
SELECT
    c2023.category,
    c2023.revenue AS revenue_2023,
    c2024.revenue AS revenue_2024,
    (c2024.revenue - c2023.revenue) AS yoy_change,
    ((c2024.revenue - c2023.revenue) * 100.0 / c2023.revenue) AS yoy_percentage
FROM category_yearly c2023
JOIN category_yearly c2024
    ON c2023.category = c2024.category
   AND c2023.sale_year = 2023
   AND c2024.sale_year = 2024
ORDER BY yoy_percentage DESC;



-- 8.3 YOY Revenue by Product (Which products improved?)

WITH product_yearly AS (
    SELECT
        s.product_id,
        p.product_name,
        YEAR(sale_date) AS sale_year,
        SUM(s.quantity * s.unit_price) AS revenue
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    GROUP BY s.product_id, p.product_name, YEAR(sale_date)
)
SELECT
    p2023.product_id,
    p2023.product_name,
    p2023.revenue AS revenue_2023,
    p2024.revenue AS revenue_2024,
    (p2024.revenue - p2023.revenue) AS yoy_change,
    ((p2024.revenue - p2023.revenue) * 100.0 / p2023.revenue) AS yoy_percentage
FROM product_yearly p2023
JOIN product_yearly p2024
    ON p2023.product_id = p2024.product_id
   AND p2023.sale_year = 2023
   AND p2024.sale_year = 2024
ORDER BY yoy_percentage DESC;


/* 
============================================================
EXPLANATION: How one CTE becomes two “views” (m2023 & m2024)
============================================================

1. The CTE monthly_revenue is ONE temporary table that contains
   all months for BOTH years (2023 and 2024).

   Example structure:
   ---------------------------------------
   | sale_year | sale_month | revenue   |
   ---------------------------------------
   |   2023    |     1      |   ...     |
   |   2023    |     2      |   ...     |
   |   2024    |     1      |   ...     |
   |   2024    |     2      |   ...     |
   ---------------------------------------

2. When we write:

       FROM monthly_revenue m2023
       JOIN monthly_revenue m2024

   SQL loads the SAME CTE twice into memory.
   These are simply two ALIASES (not two tables).

3. The JOIN conditions act like WHERE filters for each alias:

       AND m2023.sale_year = 2023
       AND m2024.sale_year = 2024

   This effectively produces:

       m2023 = rows where sale_year = 2023
       m2024 = rows where sale_year = 2024

   Even though there is no WHERE clause inside the CTE,
   the ON conditions filter the rows for each alias
   BEFORE the join happens (SQL execution order).

4. After filtering, SQL joins the 2023 rows with the 2024 rows
   using the matching month:

       m2023.sale_month = m2024.sale_month

   Result:
   -----------------------------------------------
   | Month | Revenue_2023 | Revenue_2024 | ...   |
   -----------------------------------------------

5. Summary:
   - One CTE → two aliases (two filtered views)
   - ON conditions filter each alias separately
   - JOIN aligns the matching months
   - This produces correct Year-Over-Year comparison

============================================================
*/


-- 9. ROLLING AVERAGES FOR TREND & FORECASTING
  



-- 9.1 Daily Revenue + 7-Day Rolling Average

WITH daily_revenue AS (
    SELECT
        sale_date,
        SUM(quantity * unit_price) AS daily_rev
    FROM sales
    GROUP BY sale_date
)
SELECT
    sale_date,
    daily_rev,
    AVG(daily_rev) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS rolling_7_day_avg
FROM daily_revenue
ORDER BY sale_date;



-- 9.2 Daily Revenue + 30-Day Rolling Average

WITH daily_revenue AS (
    SELECT
        sale_date,
        SUM(quantity * unit_price) AS daily_rev
    FROM sales
    GROUP BY sale_date
)
SELECT
    sale_date,
    daily_rev,
    AVG(daily_rev) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_30_day_avg
FROM daily_revenue
ORDER BY sale_date;



-- 9.3 Monthly Revenue + 3-Month Rolling Average
WITH monthly_revenue AS (
    SELECT
        DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1) AS month_start,
        SUM(quantity * unit_price) AS monthly_rev
    FROM sales
    GROUP BY DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1)
)
SELECT 
    month_start,
    monthly_rev,
    AVG(monthly_rev) OVER (
        ORDER BY month_start
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS rolling_3_month_avg
FROM monthly_revenue
ORDER BY month_start;



/* --------------------------------------------------------
   10. PROFIT & MARGIN ANALYSIS

   NOTE: Since the dataset does not include product cost,
         we assume a realistic cost-per-product using CTE.

--------------------------------------------------------*/



-- 10.1 Assign Cost Per Product (Realistic Simulation)

WITH product_costs AS (
    SELECT 
        product_id,
        CASE 
            WHEN product_id = 101 THEN 0.55   -- Chocolate Bar
            WHEN product_id = 102 THEN 0.45   -- Chips
            WHEN product_id = 103 THEN 0.15   -- Cookies
            WHEN product_id = 104 THEN 1.00   -- Candy Mix
            WHEN product_id = 105 THEN 0.30   -- Snack Pack
            WHEN product_id = 106 THEN 0.70   -- Coffee
            WHEN product_id = 107 THEN 1.50   -- Protein Bar
            WHEN product_id = 108 THEN 1.20   -- Energy Drink
            WHEN product_id = 109 THEN 0.40   -- Soda Can
            WHEN product_id = 110 THEN 0.80   -- Sparkling Water
            ELSE 0.50
        END AS cost_price
    FROM products
)



-- 10.2 Profit by Product

SELECT 
    p.product_name,
    SUM(s.quantity * s.unit_price) AS total_revenue,
    SUM(s.quantity * pc.cost_price) AS total_cost,
    SUM(s.quantity * (s.unit_price - pc.cost_price)) AS total_profit,
    (SUM(s.quantity * (s.unit_price - pc.cost_price)) * 100.0 / 
     SUM(s.quantity * s.unit_price)) AS margin_percentage
FROM sales s
JOIN product_costs pc ON s.product_id = pc.product_id
JOIN products p ON s.product_id = p.product_id
GROUP BY p.product_name
ORDER BY total_profit DESC;



-- 10.3 Category-Level Profitability

WITH profit_data AS (
    SELECT 
        p.category,
        (s.quantity * s.unit_price) AS revenue,
        (s.quantity * pc.cost_price) AS cost,
        (s.quantity * (s.unit_price - pc.cost_price)) AS profit
    FROM sales s
    JOIN product_costs pc ON s.product_id = pc.product_id
    JOIN products p ON s.product_id = p.product_id
)
SELECT 
    category,
    SUM(revenue) AS total_revenue,
    SUM(cost) AS total_cost,
    SUM(profit) AS total_profit,
    (SUM(profit) * 100.0 / SUM(revenue)) AS margin_percentage
FROM profit_data
GROUP BY category
ORDER BY margin_percentage DESC;



-- 10.4 Monthly Profit Trend (CTE)

WITH monthly_profit AS (
    SELECT
        DATEFROMPARTS(YEAR(s.sale_date), MONTH(s.sale_date), 1) AS month_start,
        SUM(s.quantity * s.unit_price) AS revenue,
        SUM(s.quantity * pc.cost_price) AS cost,
        SUM(s.quantity * (s.unit_price - pc.cost_price)) AS profit
    FROM sales s
    JOIN product_costs pc ON s.product_id = pc.product_id
    GROUP BY DATEFROMPARTS(YEAR(s.sale_date), MONTH(s.sale_date), 1)
)
SELECT 
    month_start,
    revenue,
    cost,
    profit,
    (profit * 100.0 / revenue) AS margin_percentage
FROM monthly_profit
ORDER BY month_start;




/* --------------------------------------------------------
   12. PARETO ANALYSIS (80/20 RULE)
   --------------------------------------------------------
   Business Questions:
   - Do 20% of products generate 80% of the revenue?
   - Which products contribute the most?
   - How concentrated is our revenue?
-------------------------------------------------------- */


------------------------------------------------------------
-- 12.1 Calculate revenue per product
------------------------------------------------------------
WITH product_revenue AS (
    SELECT 
        p.product_id,
        p.product_name,
        SUM(s.quantity * s.unit_price) AS revenue
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    GROUP BY p.product_id, p.product_name
),

------------------------------------------------------------
-- 12.2 Calculate total revenue
------------------------------------------------------------
total_rev AS (
    SELECT SUM(revenue) AS total_revenue
    FROM product_revenue
),

------------------------------------------------------------
-- 12.3 Rank products by revenue and compute cumulative %
------------------------------------------------------------
pareto AS (
    SELECT 
        pr.product_id,
        pr.product_name,
        pr.revenue,
        pr.revenue * 100.0 / tr.total_revenue AS revenue_percentage,
        SUM(pr.revenue) OVER (ORDER BY pr.revenue DESC) 
            * 100.0 / tr.total_revenue AS cumulative_percentage
    FROM product_revenue pr
    CROSS JOIN total_rev tr
)
SELECT *
FROM pareto
ORDER BY revenue DESC;



/* --------------------------------------------------------
   13. PRICE ELASTICITY OF DEMAND (SIMULATED)
   --------------------------------------------------------
   IMPORTANT:
   Elasticity requires real price variation over time.
   Since the current dataset uses fixed prices, this section
   demonstrates elasticity using simulated price shifts.
   
   This is standard in analytics portfolios where raw data
   does not include natural price changes.
-------------------------------------------------------- */

------------------------------------------------------------
-- 13.1 Simulate price changes for elasticity demo
------------------------------------------------------------
/* 
   We simulate small price fluctuations (±10%) 
   to observe quantity sensitivity.
*/

WITH simulated_sales AS (
    SELECT
        s.product_id,
        p.product_name,
        s.sale_date,
        s.quantity,
        -- Simulate a price variation by ±10%
        CASE 
            WHEN DATEPART(DAY, sale_date) % 3 = 0 THEN s.unit_price * 1.10
            WHEN DATEPART(DAY, sale_date) % 3 = 1 THEN s.unit_price * 0.95
            ELSE s.unit_price
        END AS simulated_price
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
),

------------------------------------------------------------
-- 13.2 Aggregate by product & price point
------------------------------------------------------------
price_quantity AS (
    SELECT
        product_id,
        product_name,
        simulated_price,
        SUM(quantity) AS total_quantity
    FROM simulated_sales
    GROUP BY product_id, product_name, simulated_price
),

------------------------------------------------------------
-- 13.3 Apply LAG to compute price & quantity deltas
------------------------------------------------------------
elasticity_calc AS (
    SELECT
        product_id,
        product_name,
        simulated_price,
        total_quantity,
        LAG(simulated_price) OVER (PARTITION BY product_id ORDER BY simulated_price) AS prev_price,
        LAG(total_quantity) OVER (PARTITION BY product_id ORDER BY simulated_price) AS prev_quantity
    FROM price_quantity
)

------------------------------------------------------------
-- 13.4 Compute elasticity
------------------------------------------------------------
SELECT
    product_id,
    product_name,
    simulated_price,
    prev_price,
    total_quantity,
    prev_quantity,
    
    -- % change in quantity
    (total_quantity - prev_quantity) * 1.0 / NULLIF(prev_quantity, 0) AS pct_quantity_change,
    
    -- % change in price
    (simulated_price - prev_price) * 1.0 / NULLIF(prev_price, 0) AS pct_price_change,
    
    -- Elasticity
    ((total_quantity - prev_quantity) * 1.0 / NULLIF(prev_quantity, 0))
    /
    ((simulated_price - prev_price) * 1.0 / NULLIF(prev_price, 0)) AS elasticity_value

FROM elasticity_calc
WHERE prev_price IS NOT NULL
ORDER BY product_id, simulated_price;


/* --------------------------------------------------------
   14. LINEAR TREND FORECASTING (SQL-BASED)
   --------------------------------------------------------
   Business Questions:
   - Is revenue trending upward or downward?
   - Based on historical pattern, what is next month's revenue?
   - What long-term direction is the business moving toward?

   NOTE:
   This is a SIMPLE linear regression forecast using SQL.
   It does not replace ML models but is excellent for 
   directional business insight and dashboarding.
-------------------------------------------------------- */


------------------------------------------------------------
-- 14.1 Build monthly revenue table
------------------------------------------------------------
WITH monthly_rev AS (
    SELECT
        DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1) AS month_start,
        SUM(quantity * unit_price) AS revenue
    FROM sales
    GROUP BY DATEFROMPARTS(YEAR(sale_date), MONTH(sale_date), 1)
),

------------------------------------------------------------
-- 14.2 Assign time index (1, 2, 3, …)
------------------------------------------------------------
indexed_rev AS (
    SELECT
        month_start,
        revenue,
        ROW_NUMBER() OVER (ORDER BY month_start) AS time_index
    FROM monthly_rev
),

------------------------------------------------------------
-- 14.3 Calculate regression slope + intercept
------------------------------------------------------------
regression AS (
    SELECT
        REGR_SLOPE(revenue, time_index)    AS slope,
        REGR_INTERCEPT(revenue, time_index) AS intercept
    FROM indexed_rev
)

------------------------------------------------------------
-- 14.4 Produce forecast for next 3 months
------------------------------------------------------------
SELECT
    ir.month_start,
    ir.revenue,
    r.slope,
    r.intercept,
    -- Predicted revenue based on Y = mX + b
    (r.slope * ir.time_index + r.intercept) AS predicted_revenue
FROM indexed_rev ir
CROSS JOIN regression r
ORDER BY ir.month_start;



